# The Grand Tour Gamble — Stage Control & Logic Final Clarifications

## ✅ Stage Progression Logic
- **Controlled by Trainer** via the Trainer Dashboard.
- **Flow:**
  1. Trainer **unlocks decision window** (checkbox toggle per stage).
  2. Participants submit Sprint/Cruise decisions.
  3. Trainer **locks stage** when ready.
  4. Edge Function is triggered → scoring, stamina, synergy updated.
  5. Trainer clicks "Next Stage" to continue.

## ✅ Decision Window Control
- Boolean field on **stage or session** (e.g., `stage_open: true/false`)
- Participants can only submit decisions while `stage_open === true`.
- Once trainer locks, UI disables decision buttons.

## ✅ Edge Function Spec (To Be Implemented)
- Trigger: Fired when trainer locks a stage
- Input:
  - `session_id`
  - all `decisions_log` entries for current stage
  - `cyclists`, `teams` state
- Output:
  - Updated `cyclists` table (points, stamina)
  - Updated `teams` table (points, synergy)
  - New `reflections_log` row (optional for stats)

## ✅ Cyclist Backstories
- Already created in this thread
- Must be stored in a dedicated `.md` file (e.g., `cyclist-backstories.md`)
- App page should render each character story via MDX

## ✅ AI Team Behavior Logic
- No randomness required — fixed behavior profile per AI team:
  - **Solaris**: 70% Cruise, 30% Sprint
  - **Corex**: 50% Cruise, 50% Sprint
  - **Vortex**: 30% Cruise, 70% Sprint
- Must be triggered inside scoring edge function at each stage

## ✅ Timer Logic (Visual Only)
- Countdown is visual only, does **not** trigger any logic
- Component for stage time remaining per phase (decision, negotiation, reflection)

## ✅ Session Locking Mechanism
- Trainer clicks “End Stage”
- Locks user inputs
- Triggers edge function for scoring
- Optionally prevents changing decisions after submission

## ✅ Reflection Mechanic
- After each stage:
  - Buttons are hidden (visible but unable to click, they are grey)
  - UI label: “Reflection Time: Discuss with your team”
  - No text input required
  - Duration controlled by trainer

## ✅ Debrief Mechanic
- At end of Stage 10:
  - Show each cyclist’s final score and choice history
  - Team Rubicon score and placement
  - Leaderboard: individual and team (4 teams x 4 cyclists)
  - Show synergy performance
- Suggestions:
  - Add stats on "most consistent" cyclist
  - Highlight negotiation success impact

## ✅ Supabase Fields to Add
1. `sessions.stage_open` (Boolean)
2. `sessions.current_stage` (Integer)
3. `decisions_log.result_applied` (Boolean or Timestamp)
4. `teams.total_synergy` (Integer)
5. `cyclists.starting_stamina` (default: 5)
6. `negotiations_log` table (for tracking alignment)

## ✅ UI Components Confirmed
- `StageController.tsx`: Trainer controls stage flow
- `LiveTimer.tsx`: Countdown only (visual)
- `DecisionButtons.tsx`: Locked/unlocked based on stage_open
- `AIEngine.ts`: Logic to compute rival team decisions
- `DebriefScreen.tsx`: Final results + stats breakdown
- `ReflectionsOverlay.tsx`: Post-stage visual blocker

## ✅ Final Control Flow
1. Trainer creates session
2. Codes distributed
3. Trainer opens stage 1
4. Players submit decision
5. Trainer ends stage 1 → triggers scoring
6. Reflection screen
7. Trainer starts next stage
8. Repeat until Stage 10
9. Game ends → debrief screen

Ready for implementation in Cursor. ✅
